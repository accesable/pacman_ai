# -*- coding: utf-8 -*-
"""searchAgent.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xZV7rDpHEnhE8cumZdkyRt8mwDaRiUFT
"""

from fringes import Queue,Stack
from problems import SingleFoodProblem,MutilFoodProblem

class SearchAgent():
  
  def bfs(self,problem):
    if(isinstance(problem,SingleFoodProblem)):
      res = self.bfsSingle(problem)
      return res
    elif(isinstance(problem,MutilFoodProblem)):
      return self.bfsMulti(problem)
    else:
      raise Exception("Invalid Problem")
    
  def dfs(self,problem):
    if(isinstance(problem,SingleFoodProblem)):
      res = self.dfsSingle(problem)
      return res
    elif(isinstance(problem,MutilFoodProblem)):
      return self.dfsMulti(problem)
    else:
      raise Exception("Invalid Problem")

  def ucs(self,problem):
    if(isinstance(problem,SingleFoodProblem)):
      res = self.ucsSingle(problem)
      return res
    elif(isinstance(problem,MutilFoodProblem)):
      return self.ucsMulti(problem)
    else:
      raise Exception("Invalid Problem")

        
  def bfsSingle(self, problem: SingleFoodProblem) -> tuple:
    expanded = [] # list of expanded vertices in the traversal order
    path = [] # path from src to dst

    # TODO 1
    q=Queue()
    q.enqueue(problem.pacman)
    parents = dict()

    while not q.empty():
      
      cur=q.dequeue()
      expanded.append(cur)
      successors = problem.getSuccessors(cur)

      for (v,w) in successors:
        if v not in expanded and not q.contain(v):
          #add item to parents dict 
          parents[v]=(cur,w)
          if v==problem.food:
            path = self.get_path(problem.pacman,problem.food,parents,problem)
            return path
          q.enqueue(v)
    return path
  
  def bfsMulti(self, problem: MutilFoodProblem) -> tuple:
    pathres=[]
    for food in problem.foods:
    
      expanded = [] # list of expanded vertices in the traversal order
      path = [] # path from src to dst

      # TODO 1
      q=Queue()
      q.enqueue(problem.pacman)
      parents = dict()

      while not q.empty():
        
        cur=q.dequeue()
        expanded.append(cur)
        successors = problem.getSuccessors(cur)
        nodeFounded = False
        for (v,w) in successors:
          if v not in expanded and not q.contain(v):
            #add item to parents dict 
            parents[v]=(cur,w)
            if v==food:
              path = self.get_path(problem.pacman,food,parents,problem)
              problem.pacman=food
              pathres.extend(path)
              nodeFounded = True
              break
            q.enqueue(v)
        if nodeFounded:
          break
    return pathres

  def get_path(self,src,dst,parents,problem):
    res = []
    res.append(dst)
    i = parents[dst]

    while not i[0] == src:
      res.append(i[0])
      i = parents[i[0]]
      
    res.append(src)
    res.reverse()
    path=[]
    for i in range(0,len(res)-1):
      path.append(problem.getWayFromNodetoNodeAdjacency(res[i],res[i+1]))
    return path

  def dfsSingle(self, problem: SingleFoodProblem) -> tuple:
    expanded = [] # list of expanded vertices in the traversal order
    path = [] # path from src to dst

    # TODO 1
    st=Stack()
    st.push(problem.pacman)
    parents = dict()

    while not st.empty():
      
      cur=st.pop()
      expanded.append(cur)
      successors = problem.getSuccessors(cur)

      for (v,w) in successors:
        if v not in expanded and not st.contain(v):
          #add item to parents dict 
          parents[v]=(cur,w)
          if v==problem.food:
            path = self.get_path(problem.pacman,problem.food,parents,problem)
            return path
          st.push(v)
    return path
  def dfsMulti(self, problem: MutilFoodProblem) -> tuple:
    pathres=[]
    for food in problem.foods:
      expanded = [] # list of expanded vertices in the traversal order
      path = [] # path from src to dst

      # TODO 1
      st=Stack()
      st.push(problem.pacman)
      parents = dict()
      nodeFounded = False

      while not st.empty():
        
        cur=st.pop()
        expanded.append(cur)
        successors = problem.getSuccessors(cur)

        for (v,w) in successors:
          if v not in expanded and not st.contain(v):
            #add item to parents dict 
            parents[v]=(cur,w)
            if v==food:
              pathres.extend(self.get_path(problem.pacman,food,parents,problem))
              problem.pacman = food
              nodeFounded=True
              break
            st.push(v)
        if nodeFounded :
          break
    return pathres

  def ucsSingle(self, problem: SingleFoodProblem) -> tuple:
    expanded = [] # list of expanded vertices in the traversal order
    path = [] # path from src to dst

    # TODO 1
    q=Queue()
    q.enqueue((problem.pacman,'start'))
    parents = dict()

    while not q.empty():
      
      cur=q.dequeue()
      expanded.append(cur)
      successors = problem.getSuccessors(cur[0])

      for (v,w) in successors:
        node = (v,w)
        if node not in expanded and not q.contain(node):
          #add item to parents dict 
          parents[node]=(cur)
          if v==problem.food:
            # print("flag")
            food= (problem.food,problem.getWayFromNodetoNodeAdjacency(cur[0],v))
            # print("Parent",parents)
            # print(food)
            path.append(self.get_path1(problem.pacman,food,parents,problem))
            # print("Path",path)
          q.enqueue(node)
    res = min(path,key=len)
    return res
  
  def ucsMulti(self, problem: MutilFoodProblem) -> tuple:
    pathres=[]
    for food in problem.foods:
      expanded = [] # list of expanded vertices in the traversal order
      path = [] # path from src to dst

      # TODO 1
      q=Queue()
      q.enqueue((problem.pacman,'start'))
      parents = dict()

      while not q.empty():
        
        cur=q.dequeue()
        expanded.append(cur)
        successors = problem.getSuccessors(cur[0])

        for (v,w) in successors:
          node = (v,w)
          if node not in expanded and not q.contain(node):
            #add item to parents dict 
            parents[node]=(cur)
            if v==food:
              # print("flag")
              food1 = (food,problem.getWayFromNodetoNodeAdjacency(cur[0],v))
              # print("Parent",parents)
              # print(food)
              path.append(self.get_path1(problem.pacman,food1,parents,problem))
              # print("Path",path)
            q.enqueue(node)
      res = min(path,key=len)
      problem.pacman = food
      pathres.extend(res)
    return pathres
  
  def get_path1(self,src,dst,parents,problem):
    res = []
    res.append(dst)
    i = parents[dst]


    while not i[0] == src:
      res.append(i)
      i = parents[i]
      
    res.append((src,problem.getWayFromNodetoNodeAdjacency(src,res[-1][0])))
    res.reverse()
    path=[]
    # print(res)
    for i in range(0,len(res)-1):
      path.append(problem.getWayFromNodetoNodeAdjacency(res[i][0],res[i+1][0]))
    return path





