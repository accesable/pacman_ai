# -*- coding: utf-8 -*-
"""problems.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xL2W0xVJCoFUYPuKLJL_JSUjrhMGxryl
"""

import numpy as np
import os

# Directed, weighted graphs
class SingleFoodProblem:
  def __init__(self):
    self.AL = dict() # adjacency list #Node list
    self.pacman=tuple()
    self.food=tuple()
    self.matrix = []

  def __str__(self):
    res=""
    for u, neighbors in self.AL.items():
      line = '%s: %s\n'%(str(u), str(neighbors))
      res += line
    return res

  def print(self):
    print(str(self))

  def getSuccessors(self,u:tuple):
    return self.AL[u]

  def getWayFromNodetoNodeAdjacency(self,srcNode,dstNode):
    for v,w in self.AL[srcNode]:
      if v==dstNode:
        return w

  def getKey(self, row,column):
    i,j=row,column
    node = (i,j)
    l=[]
    if self.matrix[i][j+1] != '%':
      l.append(((i,j+1),'E'))
    if self.matrix[i][j-1] != '%':
      l.append(((i,j-1),'W'))
    if self.matrix[i-1][j] != '%':
      l.append(((i-1,j),'N'))
    if self.matrix[i+1][j] != '%':
      l.append(((i+1,j),'S'))
    self.AL[node] = l
    
  def test_Goal(self,index):
    if index == self.food:
      return True
    return False

  def load_input_pacman(self,filename):
    #load file into matrix
    if not os.path.exists(filename):
      raise Exception("No file Founded")
    f = open(filename,'r')
    self.matrix =[]
    for line in f:
      l=[]
      for i in line:
        if i =='\n':
          continue
        l.append(i)
      self.matrix.append(l)
    
    self.matrix = np.array(self.matrix)

    #Pacman position
    row,column= np.where(self.matrix=='P')
    i,j=row[0],column[0]
    self.pacman=(i,j)
    self.getKey(i,j)
    
    #food position
    row,column= np.where(self.matrix=='.')
    i,j=row[0],column[0]
    self.food=(i,j)
    self.getKey(i,j)
    #Assign blank spaces as node in AL
                                         
    for i in range(1,len(self.matrix),1):
      for j in range(1,len(self.matrix[i]),1):
        if self.matrix[i][j]==' ':
          self.getKey(i,j)

  def printMaze(self):
    for i in self.matrix:
      for j in i:
        print(j,end='')
      print("\n",end='')
  
  def animate(self,result : list):
    for i in result:
      self.printMaze()
      input("Press enter to continue ... ")
      os.system("cls")
      self.accessKey(i)
    self.printMaze()

  def accessKey(self,key):
    if(key=='N'):
      self.goUp()
    if(key=='S'):
      self.goDown()
      return "Go down"
    if(key=='W'):
      self.goLeft()
      return "Go left"
    if(key=='E'):
      self.goRight()
      return "Go right"
    
    
  def goRight(self):
    row,column = np.where(self.matrix=='P')
    self.matrix[row[0]][column[0]]=" "
    self.matrix[row[0]][column[0]+1]="P"

  def goLeft(self):
    row,column = np.where(self.matrix=='P')
    self.matrix[row[0]][column[0]]=" "
    self.matrix[row[0]][column[0]-1]="P"

  def goUp(self):
    row,column = np.where(self.matrix=='P')
    self.matrix[row[0]][column[0]]=" "
    self.matrix[row[0]-1][column[0]]="P"

  def goDown(self):
    row,column = np.where(self.matrix=='P')
    self.matrix[row[0]][column[0]]=" "
    self.matrix[row[0]+1][column[0]]="P"

class MutilFoodProblem:
  def __init__(self):
    self.AL = dict() # adjacency list #Node list
    self.pacman=tuple()
    self.foods=list()
    self.matrix = []

  def __str__(self):
    res=""
    for u, neighbors in self.AL.items():
      line = '%s: %s\n'%(str(u), str(neighbors))
      res += line
    return res

  def print(self):
    print(str(self))

  def getSuccessors(self,u:tuple):
    return self.AL[u]

  def getWayFromNodetoNodeAdjacency(self,srcNode,dstNode):
    for v,w in self.AL[srcNode]:
      if v==dstNode:
        return w

  def getKey(self, row,column):
    i,j=row,column
    node = (i,j)
    l=[]
    if self.matrix[i][j+1] != '%':
      l.append(((i,j+1),'E'))
    if self.matrix[i][j-1] != '%':
      l.append(((i,j-1),'W'))
    if self.matrix[i-1][j] != '%':
      l.append(((i-1,j),'N'))
    if self.matrix[i+1][j] != '%':
      l.append(((i+1,j),'S'))
    self.AL[node] = l
    
  def test_Goal(self,index):
    if index == self.food:
      return True
    return False

  def load_input_pacman(self,filename):
    #load file into matrix
    if not os.path.exists(filename):
      raise Exception("File Not Found")
    f = open(filename,'r')
    self.matrix =[]
    for line in f:
      l=[]
      for i in line:
        if i =='\n':
          continue
        l.append(i)
      self.matrix.append(l)
    
    self.matrix = np.array(self.matrix)

    #Pacman position
    row,column= np.where(self.matrix=='P')
    i,j=row[0],column[0]
    self.pacman=(i,j)
    self.getKey(i,j)
    
    #food position
    row,column= np.where(self.matrix=='.')
    i,j=row[0],column[0]
    self.food=(i,j)
    self.getKey(i,j)
    for i,j in zip(row,column):
      self.foods.append((i,j))
      self.getKey(i,j)
    #Assign blank spaces as node in AL
                                         
    for i in range(1,len(self.matrix),1):
      for j in range(1,len(self.matrix[i]),1):
        if self.matrix[i][j]==' ':
          self.getKey(i,j)

  def printMaze(self):
    for i in self.matrix:
      for j in i:
        print(j,end='')
      print("\n",end='')
  
  def animate(self,result : list):
    for i in result:
      self.printMaze()
      input("Press enter to continue ... ")
      os.system("cls")
      self.accessKey(i)
    self.printMaze()

  def accessKey(self,key):
    if(key=='N'):
      self.goUp()
    if(key=='S'):
      self.goDown()
      return "Go down"
    if(key=='W'):
      self.goLeft()
      return "Go left"
    if(key=='E'):
      self.goRight()
      return "Go right"
    
    
  def goRight(self):
    row,column = np.where(self.matrix=='P')
    self.matrix[row[0]][column[0]]=" "
    self.matrix[row[0]][column[0]+1]="P"

  def goLeft(self):
    row,column = np.where(self.matrix=='P')
    self.matrix[row[0]][column[0]]=" "
    self.matrix[row[0]][column[0]-1]="P"

  def goUp(self):
    row,column = np.where(self.matrix=='P')
    self.matrix[row[0]][column[0]]=" "
    self.matrix[row[0]-1][column[0]]="P"

  def goDown(self):
    row,column = np.where(self.matrix=='P')
    self.matrix[row[0]][column[0]]=" "
    self.matrix[row[0]+1][column[0]]="P"
